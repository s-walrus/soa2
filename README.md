# СОА-2

*Домашнее задание для курса о микросервисах.*

В этом репозитории приложении для игры в минималистичную версию Мафии.

## Архитектура

Компоненты:
+ **[game-core](https://github.com/s-walrus/soa2/tree/main/services/core)** — реализует логику игры, предоставляет gRPC API и поддерживает чат через внешнюю очередь сообщений.
+ **[game-info](https://github.com/s-walrus/soa2/tree/main/services/info)** — хранит информацию о пользователях и предоставляет REST API для взаимодействия с ней.
+ **[scoreboard](https://github.com/s-walrus/soa2/tree/main/services/scoreboard)** — хранит информацию о состоянии текущих и прошедших игр, получает её от `game-core` и предоставляет GraphQL API для взаимодействия с ней.
+ **[клиент-бот](https://github.com/s-walrus/soa2/tree/main/clients/bot)** — симулирует игру пяти ботов, взаимодействуя с `game-core` через gRPC, ведёт лог всего происходящего в игре. Реализован для демонстрации функционала.
+ **[клиент-scoreboard](https://github.com/s-walrus/soa2/blob/main/clients/scoreboard.sh)** — показывает обновляемый в реальном времени scoreboard. По-факту, обёртка над `curl`.

## Реализация

Чтобы работу было удобнее проверять, а я получил все баллы, на которые рассчитываю, ниже разбор моей работы по критериям.

### Общие детали

Серверная часть реализована на Python. Вся серверная часть упакована в докер-контейнеры и поднимается через docker-compose ([docker-compose.yaml](https://github.com/s-walrus/soa2/blob/main/docker-compose.yaml)).

Для запуска всех частей приложения есть make-цели ([Makefile](https://github.com/s-walrus/soa2/blob/main/Makefile)):
+ Серверная часть запускается через `make run`. Эта цель поднимает докер образы через `docker-compose`.
+ Клиент-бот запускается без контейнеризации через `make run-bot`, но потребуется установить зависимости из `clients/bot/requirements.txt`. Можно также раскомментировать [сервис бот-клиента](https://github.com/s-walrus/soa2/blob/main/docker-compose.yaml#L37) в `docker-compose.yaml` и как-нибудь читать вывод контейнера.
+ Клиент `scoreboard` запускается через `make run-scoreboard`.
+ Чтобы протестировать REST-клиент, можно подёргать его энпоинты через `curl localhost:8081/...`.

Я разрабатывал приложение как единое, не деля его на 4 части и не выполняя задания последовательно, поэтому реализация домашних заданий зависит друг от друга. Ниже я разбираю, как получившееся приложение удовлетворяет критериям. Делаю это, чтобы (1) было удобнее проверять и (2) не потерять баллы, если моя интерпретация условия отличается от неявно ожидаемой.

### 2. Приложение на основе gRPC

> Реализовать базовое клиент-серверное приложение «Привет Мафия» на основе технологии gRPC.  
> Клиент обеспечивает:
> 1)  Установку имени пользователя 
> 2)  Подключение к серверу по сетевому имени/адресу
> 3)  Отображение списка подключившихся игроков
>
> Сервер обеспечивает:
> 1)  Подключение игроков
> 2)  Рассылку уведомлений о подключившихся/отключившихся игроках **— 4 балла**

Сервис `game-core` реализует всю логику по проведению игры и предоставляет gRPC API для подключения игроков и выполнения ими действий в игре, включая общение. Обратную связь клиент получает, в основном, через чат, который описан в следующем разделе.

Клиент выполнен в виде скрипта, который симулирует игру 5 ботов: они независимо взаимодейтсвуют с сервером через gRPC, а чат транслируется в поток вывода. Так он обеспечивает подключение 5 игроков-ботов по url и отображает подключившихся/отключившихся игроков, транслируя сообщения из чата.

Ручной клиент, через который можно было бы поиграть в мафию самому, не реализован, потому что это сложнее, чем писать бота, и выходит за рамки курса. Но сервер предоставляет всё необходимое для этого API. API я разрабатывал с рассчётом на ручной клиент.

> Реализовать базовое приложение «Боты мафии». Оно реализует все возможности приложения «Привет Мафия», а также:  
> Клиент обеспечивает:
> 1) Автоматический вход в сессию игры, когда набирается достаточное число игроков
> 2) Отображение состояния игрока и действий, происходящих в игре
> 3) Случайный выбор действий среди возможных на каждом этапе игры
> Сервер обеспечивает:
> 1) Создание одной сессии игры при подключении достаточного количества игроков
> 2) Назначение игрокам случайных ролей в соответствии с требованиями
> 3) Получение от игроков выбранных действий, их выполнение и изменение состояния игроков
> 4) Учет статуса игры и завершение игры при выигрыше мирных жителей или мафии
> 5) Возможность ведения нескольких сеансов игры одновременно, назначая каждому из сеансов уникальный идентификатор. **— 6 баллов**

Выполнено.

1) Клиент автоматически подключается к игре.
2) Информация с состоянии игроков и действиях в игре транслируется клиентом в поток вывода.
6) Клиент с небольшим интервалом выполняет случайные действия, вызвая gRPC-методы.

1) Сервер начинает игру, когда к сессии подключается достаточное число игроков (пять)
2) Когда игра начинается, сервер раздаёт игрокам роли.
3) Сервер получает от клиентов действия игроков через gRPC, выполняет их, изменяет состояние и пишет об этом в чат (кроме секретных действий, таких как голосование мафии).
4) Игра завершается при выигрыше одной из сторон.
5) Сервер поддерживает ведение множества игровых сессий параллельно. Для безопасности, с каждым запросом клиент отправляет токен игрока, по которому определяется, какой игрок совершает действие, и в какой сессии искать игрока.


### 3. Клиент-серверный чат

> Реализовать серверное приложение чата, использующее брокер сообщений на выбор обучающего. В качестве названия очереди использовать идентификатор сессии для возможности реализации независимых игровых сессий (комнат для общения).
> 
> В клиентская часть может быть представлена в виде консольного или диалогового приложения. Однако если вы планируете реализовывать последующие задачи, то следует модифицировать клиентское приложение, разработанное в предыдущей практике. **— 5 баллов**

В качестве чата выступает RabbitMQ контейнер. Сообщения в него отправляет `game-core`, включая сообщения пользователей по запросу (это сделано, чтобы сервер контроллировал общение и правильно форматировал все сообщения).
+ Чат также выступает интерфейсом, по которому клиент получает всю информацию о происходящем в игре (персонаж игрока умер, день завершился и т.д.), кроме своей роли: её клиент получает через gRPC.
+ Клиент чата встроен в бот-клиент: он подписывается на очередь и пишет всё, что читает.
+ Для каждой игровой сессии создаётся отдельная очередь сообщений.
+ Очередь поддерживает лишь одного подписчика — предполагается, что сообщения будут транслироваться в общий канал связи между игроками, такой как беседа в телеграме.

> Модифицировать клиент и сервер таким образом, чтобы они обеспечивали возможность общения игроков внутри сессии с учетом состояния игры: днем все игроки могут свободно общаться, ночью могут общаться только игроки мафии между собой, «духи» отключаются от общения до новой сессии игры. Для этого необходимо наладить взаимодействие с gRPC сервисом, разработанным в предыдущей практике **— 5 баллов**

Выполнено. Сервер контролирует общение в чате: для отправки сообщения клиент отправлят запрос в `game-core`.

### 4. REST веб-сервис

> Реализовать REST-сервис, который предоставляет возможность добавления, просмотра, редактирования и удаления следующей информации по профилю игрока: имя, аватар, пол, e-mail
> Должна быть обеспечена возможность получения профиля как отдельного игрока, так и перечня игроков. **— 4 балла**

Сервис `game-info` предоставляет REST API для просмотра, изменения и удаления (CRUD) всей указанной в задании информации об игроках, включая загрузку и скачивание изображений. Также позволяет искать профили игроков регулярным выражением.

API:
```
/profile/info?username={string} GET/PUSH/PUT/DELETE

/profile/query?username={regex} GET
    возвращает профили всех игроков, сматченные регулярным выражением

/profie/image?username={string} GET/POST/DELETE
    сказать, загрузить или удалить изображение
```

### 5. GraphQL веб-сервис

> Реализовать GraphQL-сервис, который предоставляет возможность просмотра списка текущих и прошлых игр, просмотр Scoreboard конкретной игры, а также добавление комментариев к играм. **— 5 баллов**

Сервис `scoreboard` предоставляет GraphQL API, по которому доступен список всех игр, информация о конкретной игре и mutation для добавления комментариев. `game-core` уведомляет `scoreboard` о всех изменениях в счёте.

> Реализовать клиент GraphQL-сервиса на любом языке. Клиент должен обеспечивать получение списка текущих и прошлых игр, просмотр Scoreboard конкретной игры, а также добавление комментариев к играм. Открытый Scoreboard должен обновляться в соответствии с изменениями игровой ситуации. **— 5 баллов**

Клиент доступен через `make run-scoreboard`. Он представляет из себя bash-скрипт, регулярно запрашивающий информацию у `scoreboard` через `curl` и форматирующий вывод. Клиент позволяет смотреть список текущих и прошлых игр, обновляющийся в реальном времени счёт любой игры и комментарии к играх. Клиент очень простой без кнопочек, потому что это задание по СОА, а не про фронтенду.

### Footnote

По моим подсчётам, выходит 10 баллов за ДЗ #2, #3 и #5 и 4 балла за ДЗ #4. Если будут вопросы, я могу поотвечать в телеграме: @swalrus
